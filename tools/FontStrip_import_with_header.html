<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>4-Grayscale Strip → 2bpp Bitmap Font (Arduino)</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 16px; }
    .row { display: flex; gap: 16px; flex-wrap: wrap; align-items: flex-start; }
    .card { border: 1px solid #ddd; border-radius: 10px; padding: 12px; }
    label { display:block; font-size: 13px; margin: 8px 0 4px; }
    input[type="text"], textarea { width: min(800px, 92vw); font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    textarea { height: 90px; }
    button { padding: 8px 12px; border-radius: 8px; border: 1px solid #ccc; background: #fafafa; cursor: pointer; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    canvas { image-rendering: pixelated; border: 1px solid #ddd; border-radius: 10px; }
    .hint { font-size: 12px; color: #444; line-height: 1.35; max-width: 900px; }
    .warn { color: #b00; font-weight: 600; }
    pre { white-space: pre-wrap; word-break: break-word; }
    table { border-collapse: collapse; font-size: 13px; }
    th, td { border: 1px solid #ddd; padding: 4px 6px; }
  </style>
</head>
<body>
  <h2>Image Strip → 4 Grays → 2bpp Font (vertical-serialized, column-major)</h2>

  <div class="card">
    <div class="row">
      <div>
        <label>1) Load strip image (single horizontal row of glyphs)</label>
        <input id="file" type="file" accept="image/*" />
        <div class="hint">
          Height must be exactly <b>8</b>, <b>12</b>, or <b>16</b> pixels.<br/>
          Glyphs are delimited by a <b>1-pixel black</b> vertical column (full height). Multiple black columns are accepted and will be compacted to 1.
        </div>

        <label>2) Characters in order (must match glyph count)</label>
        <textarea id="chars" placeholder="e.g.  !&quot;#$%&amp;'()*+,-./0123456789:;..."></textarea>

        <label>Options</label>

        <div class="hint" style="margin-top:8px">
          <label for="spaceWidth">Space width (pixels)</label>
          <input id="spaceWidth" type="number" min="0" max="32" value="3" />
        </div>

        <div class="hint">
          <input id="msb" type="checkbox" checked />
          <label for="msb" style="display:inline">Pack bits <b>MSB-first</b> in each byte (recommended)</label>
        </div>
        <div class="hint">
          <input id="includeSpaces" type="checkbox" />
          <label for="includeSpaces" style="display:inline">Allow glyph width 0? (usually <b>off</b>; checked means keep empty glyphs if present)</label>
        </div>

        <div class="hint" style="margin-top:8px">
          <label for="delim" style="display:block;margin:0 0 4px">Delimiter column (per pixel 2-bit value)</label>
          <select id="delim">
            <option value="00" selected>00 (black)  → 0x00..</option>
            <option value="01">01 (dark)   → 0x55..</option>
            <option value="10">10 (light)  → 0xAA..</option>
            <option value="11">11 (white)  → 0xFF..</option>
          </select>
        </div>

        <div style="margin-top:10px" class="row">
          <button id="process" disabled>Process + Encode</button>
          <button id="copy" disabled>Copy Arduino code</button>
        </div>

        <div id="status" class="hint" style="margin-top:10px"></div>
      </div>

      <div>
        <label>Original</label>
        <canvas id="cvOrig" width="1" height="1"></canvas>
        <label style="margin-top:12px">Pre-processed (compacted separators + 4-gray quantized)</label>
        <canvas id="cvPre" width="1" height="1"></canvas>
      </div>
    </div>
  </div>

  <div class="card" style="margin-top:16px">
    <h3 style="margin-top:0">Arduino output</h3>
    <div class="hint">
      Encoding is <b>column-major</b>: for each glyph, for each column <code>x</code> left→right,
      serialize pixels top→bottom into a bitstream where each pixel contributes <b>2 bits</b> (00 black, 01 dark-gray, 10 light-gray, 11 white).
      That yields <b>H/4 bytes per column</b> (8→2, 12→3, 16→4).<br/>
      Then continue with the next column, then the next glyph.
    </div>
    <pre id="out"></pre>
  </div>

  <div class="card" style="margin-top:16px">
    <h3 style="margin-top:0">Glyph debug</h3>
    <div id="dbg" class="hint"></div>
  </div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);

  const fileEl = $("file");
  const charsEl = $("chars");
  const processBtn = $("process");
  const copyBtn = $("copy");
  const statusEl = $("status");
  const outEl = $("out");
  const dbgEl = $("dbg");
  const msbEl = $("msb");
  const includeSpacesEl = $("includeSpaces");
  const delimEl = $("delim");
  const spaceWidthEl = $("spaceWidth");

  const cvOrig = $("cvOrig");
  const cvPre = $("cvPre");
  const cxOrig = cvOrig.getContext("2d", { willReadFrequently: true });
  const cxPre  = cvPre.getContext("2d", { willReadFrequently: true });

  /** Loaded image pixels (RGBA), and derived grayscale info */
  let loaded = null; // { w,h, imgData }

  fileEl.addEventListener("change", async () => {
    outEl.textContent = "";
    dbgEl.textContent = "";
    copyBtn.disabled = true;
    processBtn.disabled = true;
    status("");

    const f = fileEl.files && fileEl.files[0];
    if (!f) return;

    const url = URL.createObjectURL(f);
    try {
      const img = await loadImage(url);
      URL.revokeObjectURL(url);

      const w = img.naturalWidth || img.width;
      const h = img.naturalHeight || img.height;

      cvOrig.width = w; cvOrig.height = h;
      cxOrig.clearRect(0, 0, w, h);
      cxOrig.drawImage(img, 0, 0);

      const imgData = cxOrig.getImageData(0, 0, w, h);
      loaded = { w, h, imgData };

      if (![8,12,16].includes(h)) {
        status(`Image height is ${h}px. Must be exactly 8, 12, or 16.`, true);
        return;
      }

      status(`Loaded ${w}×${h}. Ready.`);
      processBtn.disabled = false;
    } catch (e) {
      status("Failed to load image: " + (e?.message || e), true);
    }
  });

  processBtn.addEventListener("click", () => {
    outEl.textContent = "";
    dbgEl.textContent = "";
    copyBtn.disabled = true;

    if (!loaded) return;
    const { w, h, imgData } = loaded;

    // 1) Quantize each pixel to 4 grayscale levels, map to 2-bit values 0..3
    //    Nearest to [0, 85, 170, 255] using thresholds at 42.5, 127.5, 212.5
    const q = quantizeTo2bpp_detectLevels(w, h, imgData.data);

    // 2) Split/compact glyphs based on full-height black separator columns
    const glyphs = splitGlyphsByBlackColumns(q, w, h, includeSpacesEl.checked);

    // Validate char string vs glyph count
    const chars = [...charsEl.value]; // simple codepoints; assumes user provides matching glyphs
    if (chars.length !== glyphs.length) {
      status(
        `Glyph count mismatch: detected ${glyphs.length} glyph(s), but chars string has ${chars.length} character(s).`,
        true
      );
      // Still show preprocessed strip for debugging
    } else {
      status(`Detected ${glyphs.length} glyph(s). Encoding…`);
    }

    // 3) Render preprocessed strip
    renderPreprocessedStrip(glyphs, h);

    // 4) Encode to byte array (2bpp, column-major, vertical-serialized)
   
    const bytesPerCol = h / 4;
    const packMSBFirst = msbEl.checked;
    const delimCol = makeAllBlackColumnBytes(h);
    const fontBytes = [];
    const widths = [];
    const offsets = []; // byte offsets into fontBytes for each glyph
    let byteOffset = 0;

    for (let gi = 0; gi < glyphs.length; gi++) {
    const g = glyphs[gi];

    // encode glyph columns
    for (let x = 0; x < g.w; x++) {
        const colBytes = packColumn2bpp(g, x, h, packMSBFirst);
        for (const b of colBytes) fontBytes.push(b);
    }

    // encode ONE black delimiter column after each glyph except the last
    if (gi !== glyphs.length - 1) {
        for (const b of delimCol) fontBytes.push(b);
    }
    }

    // 5) Format Arduino code (emit a single packed dataset blob with header + ranges + glyph data)
    const arrNameBlob = `font_2b${h}_blob`;

    // If chars match glyphs, we can drop spaces (0x20) from BOTH the char stream and the glyph stream
    // (spaces are not stored as glyphs; render-time will handle them).
    let glyphsPacked = glyphs;
    let charsPacked = chars;

    if (chars.length === glyphs.length) {
      const g2 = [];
      const c2 = [];
      for (let i = 0; i < chars.length; i++) {
        if (chars[i].codePointAt(0) === 0x20) continue; // skip space glyph entirely
        g2.push(glyphs[i]);
        c2.push(chars[i]);
      }
      glyphsPacked = g2;
      charsPacked = c2;
    }

    // Build range table from charsPacked order: consecutive runs become (first,last).
    // Assumes there are no gaps within each run for the packed dataset.
    const ranges = computeRangesFromChars(charsPacked);

    const rangeCount = ranges.length;
    const glyphDataOffsetBytes = 6 + 2 * rangeCount; // header(6) + ranges(2 bytes each)
    const delimByte = byteForRepeated2Bits(parseInt(delimEl.value, 2));

    // Re-encode using glyphsPacked (so spaces are excluded from the stored glyph stream)
    const fontBytes2 = [];
    for (let gi = 0; gi < glyphsPacked.length; gi++) {
      const g = glyphsPacked[gi];
      for (let x = 0; x < g.w; x++) {
        const colBytes = packColumn2bpp(g, x, h, packMSBFirst);
        for (const b of colBytes) fontBytes2.push(b);
      }
      // delimiter column between stored glyphs (not after last)
      if (gi !== glyphsPacked.length - 1) {
        for (let k = 0; k < bytesPerCol; k++) fontBytes2.push(delimByte);
      }
    }

    const spaceWidth = parseInt(spaceWidthEl.value, 10) & 0xFF;

    const headerBytes = [
      glyphDataOffsetBytes & 0xFF, // byte 0
      h & 0xFF,                    // byte 1
      2,                           // byte 2 (bpp)
      spaceWidth,                  // byte 3: spaceWidth
      delimByte & 0xFF,            // byte 4
      rangeCount & 0xFF            // byte 5
    ];

    const rangeBytes = [];
    for (let i = 0; i < ranges.length; i++) {
      rangeBytes.push(ranges[i][0] & 0xFF, ranges[i][1] & 0xFF);
    }

    const blobBytes = headerBytes.concat(rangeBytes, fontBytes2);

    const arduino =
`// Packed 2bpp (4-grayscale) font blob, height=${h}
// Encoding (glyph data body): column-major; each column is ${bytesPerCol} byte(s) (because ${h} pixels * 2 bpp = ${(h*2)} bits = ${bytesPerCol} bytes)
// Pixel mapping: 00 black, 01 dark-gray, 10 light-gray, 11 white
// Delimiter column: byte 0x${(delimByte).toString(16).padStart(2,'0').toUpperCase()} repeated ${bytesPerCol} time(s) per delimiter-column (between glyphs)

const uint8_t ${arrNameBlob}[] PROGMEM = {

  0x${(headerBytes[0]).toString(16).padStart(2,'0').toUpperCase()},     // byte 0: glyphDataOffsetBytes
  0x${(headerBytes[1]).toString(16).padStart(2,'0').toUpperCase()},     // byte 1: height
  0x${(headerBytes[2]).toString(16).padStart(2,'0').toUpperCase()},     // byte 2: bpp (bits per pixel)
  0x${(headerBytes[3]).toString(16).padStart(2,'0').toUpperCase()},     // byte 3: spaceWidth
  0x${(headerBytes[4]).toString(16).padStart(2,'0').toUpperCase()},     // byte 4: delimByte
  0x${(headerBytes[5]).toString(16).padStart(2,'0').toUpperCase()},     // byte 5: rangeCount

  // byte 6.. : CharCode range records (first,last) * rangeCount
  ${formatRangesForC(ranges)}
  // glyph data (${fontBytes2.length} bytes) begins at byte offset ${glyphDataOffsetBytes}
  ${formatHexBytes(fontBytes2, 16)}
};
`;

    outEl.textContent = arduino;
    copyBtn.disabled = false;

    // 6) Debug table
    dbgEl.innerHTML = glyphDebugTable(glyphs, chars);

    status(
      (chars.length === glyphs.length)
        ? `Done. ${glyphs.length} glyph(s), ${fontBytes.length} byte(s) emitted.`
        : `Preprocessed + encoded, but chars mismatch (see warning above).`,
      chars.length !== glyphs.length
    );
  });

  copyBtn.addEventListener("click", async () => {
    try {
      await navigator.clipboard.writeText(outEl.textContent || "");
      status("Copied Arduino code to clipboard.");
    } catch {
      status("Clipboard copy failed (browser permissions). Select and copy manually.", true);
    }
  });

  function status(msg, isWarn=false) {
    statusEl.innerHTML = msg ? `<span class="${isWarn ? "warn" : ""}">${escapeHtml(msg)}</span>` : "";
  }

  function loadImage(url) {
    return new Promise((res, rej) => {
      const img = new Image();
      img.onload = () => res(img);
      img.onerror = () => rej(new Error("Image load error"));
      img.src = url;
    });
  }

  function quantizeTo2bpp_detectLevels(w, h, rgba) {
  // Build histogram of luminance values in the image
  const hist = new Uint32Array(256);
  const lumArr = new Uint8Array(w*h);

  for (let i = 0; i < w*h; i++) {
    const r = rgba[i*4+0], g = rgba[i*4+1], b = rgba[i*4+2], a = rgba[i*4+3];
    const rr = (a === 0) ? 255 : r;
    const gg = (a === 0) ? 255 : g;
    const bb = (a === 0) ? 255 : b;
    const lum = Math.round(0.2126*rr + 0.7152*gg + 0.0722*bb);
    lumArr[i] = lum;
    hist[lum]++;
  }

  // Collect luminance values actually present (ignore super-rare noise)
  const present = [];
  for (let v = 0; v < 256; v++) {
    if (hist[v] > 0) present.push(v);
  }

  // If we have >= 4 distinct levels, map the 4 most frequent levels to 0..3 by luminance order.
  // (This matches your strip: black + 2 grays + near-white.)
  const byFreq = present
    .map(v => [v, hist[v]])
    .sort((a,b) => b[1] - a[1]);

  const top = byFreq.slice(0, 4).map(x => x[0]).sort((a,b) => a-b);

  // Fallback if weird image: use thresholds
  const useTop = (top.length === 4);

  const out = new Uint8Array(w*h);
  for (let i = 0; i < w*h; i++) {
    const lum = lumArr[i];
    let v2;
    if (useTop) {
      // map to nearest of the 4 detected representative levels
      let best = 0, bestD = 1e9;
      for (let k = 0; k < 4; k++) {
        const d = Math.abs(lum - top[k]);
        if (d < bestD) { bestD = d; best = k; }
      }
      v2 = best; // 0..3
    } else {
      if (lum < 64) v2 = 0;
      else if (lum < 128) v2 = 1;
      else if (lum < 192) v2 = 2;
      else v2 = 3;
    }
    out[i] = v2;
  }
  return out;
}


function makeAllBlackColumnBytes(h) {
  const bytesPerCol = h / 4;      // 12px => 3 bytes
  return new Array(bytesPerCol).fill(0x00);
}

  function splitGlyphsByBlackColumns(q, w, h, keepEmptyGlyphs) {
    // A separator column is "all black" => all q[x,y] == 0 for y in [0..h-1]
    const isSep = new Array(w).fill(false);
    for (let x = 0; x < w; x++) {
      let allBlack = true;
      for (let y = 0; y < h; y++) {
        if (q[y*w + x] !== 0) { allBlack = false; break; }
      }
      isSep[x] = allBlack;
    }

    // Find non-sep segments (glyphs). Accept multiple sep columns; compact later.
    // Trim leading/trailing separators.
    let start = 0;
    while (start < w && isSep[start]) start++;
    let end = w - 1;
    while (end >= 0 && isSep[end]) end--;
    if (end < start) return []; // all separators (or empty)

    const glyphs = [];
    let x = start;
    while (x <= end) {
      // Consume a glyph segment (non-sep columns)
      let gx0 = x;
      while (x <= end && !isSep[x]) x++;
      let gx1 = x - 1;

      const gw = gx1 - gx0 + 1;
      if (gw > 0 || keepEmptyGlyphs) {
        glyphs.push(extractGlyph(q, w, h, gx0, gw));
      }

      // Consume separator run (>=1). We don't store it; we compact to 1 when rendering preview.
      while (x <= end && isSep[x]) x++;
    }
    return glyphs;
  }

  function extractGlyph(q, w, h, gx0, gw) {
    // Store pixels column-major for convenience
    // g.px[y*gw + x] in 2-bit values
    const px = new Uint8Array(gw * h);
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < gw; x++) {
        px[y*gw + x] = q[y*w + (gx0 + x)];
      }
    }
    return { w: gw, px };
  }

  function renderPreprocessedStrip(glyphs, h) {
    // Concatenate glyphs with a single black separator column between them
    const sep = 1;
    const totalW = glyphs.length
      ? glyphs.reduce((sum, g) => sum + g.w, 0) + sep * Math.max(0, glyphs.length - 1)
      : 1;

    cvPre.width = totalW;
    cvPre.height = h;

    const imgData = cxPre.createImageData(totalW, h);
    const d = imgData.data;

    const level = (v2) => (v2 === 0 ? 0 : v2 === 1 ? 85 : v2 === 2 ? 170 : 255);

    let ox = 0;
    for (let gi = 0; gi < glyphs.length; gi++) {
      const g = glyphs[gi];
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < g.w; x++) {
          const v = level(g.px[y*g.w + x]);
          const idx = (y*totalW + (ox + x)) * 4;
          d[idx+0] = v; d[idx+1] = v; d[idx+2] = v; d[idx+3] = 255;
        }
      }
      ox += g.w;

      // separator (black)
      if (gi !== glyphs.length - 1) {
        for (let y = 0; y < h; y++) {
          const idx = (y*totalW + ox) * 4;
          d[idx+0] = 0; d[idx+1] = 0; d[idx+2] = 0; d[idx+3] = 255;
        }
        ox += 1;
      }
    }

    cxPre.putImageData(imgData, 0, 0);
    // Scale up visually via CSS
    cvOrig.style.width = (loaded.w * 3) + "px";
    cvOrig.style.height = (loaded.h * 3) + "px";
    cvPre.style.width  = (totalW * 3) + "px";
    cvPre.style.height = (h * 3) + "px";
  }

  function packColumn2bpp(g, colX, h, msbFirst) {
    // Pack y=0..h-1, each 2 bits, into h*2 bits => h/4 bytes
    const totalBits = h * 2;
    const totalBytes = totalBits / 8; // because h in {8,12,16}
    const out = new Uint8Array(totalBytes);

    let bitPos = 0; // 0..(totalBits-1)
    for (let y = 0; y < h; y++) {
      const v2 = g.px[y*g.w + colX] & 0x3; // 0..3
      // write 2 bits, high bit then low bit (so 2-bit symbol order is consistent)
      writeBit(out, bitPos++, (v2 >> 1) & 1, msbFirst);
      writeBit(out, bitPos++, (v2 >> 0) & 1, msbFirst);
    }
    return Array.from(out);
  }

  function writeBit(byteArr, bitIndex, bitValue, msbFirst) {
    const byteIndex = (bitIndex / 8) | 0;
    const bitInByte = bitIndex % 8;
    const mask = msbFirst ? (1 << (7 - bitInByte)) : (1 << bitInByte);
    if (bitValue) byteArr[byteIndex] |= mask;
  }

  function formatHexBytes(bytes, perLine) {
    if (!bytes.length) return "";
    const parts = bytes.map(b => "0x" + b.toString(16).padStart(2, "0").toUpperCase());
    const lines = [];
    for (let i = 0; i < parts.length; i += perLine) {
      lines.push(parts.slice(i, i+perLine).join(", "));
    }
    return lines.join(",\n  ");
  }


// Repeat a 2-bit pattern across a full byte: 00->0x00, 01->0x55, 10->0xAA, 11->0xFF
function byteForRepeated2Bits(v2) {
  switch (v2 & 3) {
    case 0: return 0x00;
    case 1: return 0x55;
    case 2: return 0xAA;
    case 3: return 0xFF;
  }
}

// Convert an ordered char array to consecutive (first,last) ranges (inclusive).
// Example: ['!','"','#'] -> [[0x21,0x23]]
function computeRangesFromChars(charsArr) {
  const codes = charsArr.map(ch => ch.codePointAt(0)).filter(c => c !== 0x20);
  if (!codes.length) return [];
  const ranges = [];
  let a = codes[0], b = codes[0];
  for (let i = 1; i < codes.length; i++) {
    const c = codes[i];
    if (c === b + 1) {
      b = c;
    } else {
      ranges.push([a, b]);
      a = b = c;
    }
  }
  ranges.push([a, b]);
  return ranges;
}

function formatRangesForC(ranges) {
  if (!ranges.length) return "  // (no ranges)\n";
  const lines = [];
  for (let i = 0; i < ranges.length; i++) {
    const a = ranges[i][0], b = ranges[i][1];
    //lines.push(`  0x${a.toString(16).padStart(2,'0').toUpperCase()}, 0x${b.toString(16).padStart(2,'0').toUpperCase()}, // range ${i}: [0x${a.toString(16).padStart(2,'0').toUpperCase()}..0x${b.toString(16).padStart(2,'0').toUpperCase()}]`);
    lines.push(`  0x${a.toString(16).padStart(2,'0').toUpperCase()}, 0x${b.toString(16).padStart(2,'0').toUpperCase()}, // range ${i}: '${String.fromCharCode(a)}' .. '${String.fromCharCode(b)}'`);

  }
  return lines.join("\n") + "\n";
}

  function toCCharLiteral(ch) {
    // Return a single-quoted C/C++ character literal, escaping common cases
    // Note: This is byte-oriented; for non-ASCII, Arduino 'char' may not match.
    switch (ch) {
      case "'": return "'\\''";
      case "\\": return "'\\\\'";
      case "\n": return "'\\n'";
      case "\r": return "'\\r'";
      case "\t": return "'\\t'";
      case "\0": return "'\\0'";
      default: {
        const code = ch.codePointAt(0);
        if (code >= 32 && code <= 126) return `'${ch}'`;
        // Fallback: hex escape in a character literal (implementation-defined for >0xFF)
        if (code <= 0xFF) return `0x${code.toString(16).padStart(2,"0").toUpperCase()}`;
        return `/* U+${code.toString(16).toUpperCase()} */ '?'\n`;
      }
    }
  }

  function glyphDebugTable(glyphs, chars) {
    const rows = glyphs.map((g, i) => {
      const ch = (i < chars.length) ? chars[i] : "";
      const display = (ch === " ") ? "␠" : ch;
      return `<tr><td>${i}</td><td>${escapeHtml(display)}</td><td>${g.w}</td></tr>`;
    }).join("");
    return `
      <table>
        <thead><tr><th>#</th><th>Char</th><th>Width (px)</th></tr></thead>
        <tbody>${rows}</tbody>
      </table>
    `;
  }

  function escapeHtml(s) {
    return String(s).replace(/[&<>"']/g, (c) => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
    }[c]));
  }
})();
</script>
</body>
</html>
