<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SSD1306 4-Level → 2 Bitmaps Converter</title>
  <style>
    :root { --gap: 12px; --pad: 14px; --radius: 14px; }
    * { box-sizing: border-box; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
    body { margin: 0; padding: var(--pad); background: #111; color: #eee; }
    h1 { font-size: 20px; margin: 0 0 var(--gap) 0; font-weight: 700; }
    .panel { background: #1a1a1a; border: 1px solid #2a2a2a; border-radius: var(--radius); padding: var(--pad); margin-bottom: var(--gap); }
    label { font-size: 13px; color: #bbb; display: block; margin-bottom: 6px; }
    input[type="file"], select, button { background: #0f0f0f; color: #eee; border: 1px solid #2c2c2c; border-radius: 10px; padding: 10px 12px; }
    button { cursor: pointer; }
    button:hover { background: #151515; }
    .row { display: grid; grid-template-columns: 1fr; gap: var(--gap); }
    .row.two { grid-template-columns: 1fr 1fr; }
    .controls { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: var(--gap); align-items: end; }
    .canvas-wrap { display: grid; grid-template-columns: 1fr; gap: var(--gap); }
    .canvas-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: var(--gap); }
    canvas { background: #000; border: 1px solid #333; border-radius: 8px; image-rendering: pixelated; width: 100%; height: auto; }
    textarea { width: 100%; min-height: 240px; resize: vertical; background: #0f0f0f; color: #eee; border: 1px solid #2c2c2c; border-radius: 10px; padding: 10px 12px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 12px; }
    .flex { display: flex; gap: var(--gap); align-items: center; }
    .muted { color: #9aa; font-size: 12px; }
    .nowrap { white-space: nowrap; }
    .spacer { flex: 1; }
    .hint { font-size: 12px; color: #9aa; }
    .badge { display: inline-block; padding: 2px 8px; border: 1px solid #333; border-radius: 999px; font-size: 12px; color: #ccc; }
  </style>
</head>
<body>
  <h1>SSD1306 4-Level → 2 Bitmaps Converter</h1>

  <div class="panel">
    <div class="row two">
      <div>
        <label for="imgInput">Upload image (no resizing is applied)</label>
        <input id="imgInput" type="file" accept="image/*" />
      </div>
      <div>
        <label for="sizeSelect">OLED format (SSD1306)</label>
        <select id="sizeSelect"></select>
      </div>
    </div>

    <div class="hint" style="margin-top:8px;">
      Image is quantized to 4 levels, then split into two B/W images:
      <br/>• White → white in both
      <br/>• Light gray → black in #1, white in #2
      <br/>• Dark gray → white in #1, black in #2
      <br/>• Black → black in both
    </div>
  </div>

  <div class="panel canvas-wrap">
    <div class="flex">
      <div class="badge" id="dimBadge">128×64</div>
      <div class="spacer"></div>
      <span class="muted" id="status">No image loaded.</span>
    </div>

    <div class="canvas-grid">
      <div>
        <div class="muted" style="margin-bottom:6px;">Quantized 4-level (preview)</div>
        <canvas id="canvas" width="128" height="64"></canvas>
      </div>
      <div>
        <div class="muted" style="margin-bottom:6px;">Output #1 (B/W)</div>
        <canvas id="canvasOut1" width="128" height="64"></canvas>
      </div>
      <div>
        <div class="muted" style="margin-bottom:6px;">Output #2 (B/W)</div>
        <canvas id="canvasOut2" width="128" height="64"></canvas>
      </div>
    </div>

    <div class="flex">
      <button id="quantizeBtn" title="Quantize current canvas to 4 grayscale levels">Quantize 4-level</button>
      <button id="splitBtn" title="Split 4-level image into two B/W outputs">Split → 2×B/W</button>


    <label class="muted" style="display:flex;align-items:center;gap:8px;margin:0;">
      <input id="xorChk" type="checkbox" />
      XOR bitmap2 with bitmap1 before compression
    </label>

    <div hidden>
    <label class="muted" style="display:flex;align-items:center;gap:8px;margin:0;">
    <input id="xyChk" type="checkbox" />
    X->Y transform both bitmaps before compression
    </label>
    </div>

      <div class="spacer"></div>


<button id="convertBtn">Convert → 2 Byte Arrays</button>
<button id="zrBtn" disabled title="Compress bitmap1+bitmap2 as one array using ZeroRun">Compress ZeroRun</button>
<button id="pbBtn" disabled title="Compress bitmap1+bitmap2 as one array using PackBits">Compress PackBits</button>

    </div>
  </div>

  <div class="panel">
    <div class="flex" style="margin-bottom:6px;">
      <label class="nowrap" style="margin:0;">Output byte arrays</label>
      <div class="spacer"></div>
      <button id="copyBtn" title="Copy to clipboard">Copy</button>
    </div>
    <textarea id="output" spellcheck="false" placeholder="Click ‘Convert → 2 Byte Arrays’ to generate two arrays."></textarea>
    <div class="hint" style="margin-top:6px;">
      Format: vertical bytes, LSB at (x, y) = (0, 0), MSB at (0, 7); next byte LSB at (1, 0)… page by page (8-pixel high pages).
    </div>
  </div>

  <script>
    // Common SSD1306 formats (width × height). Heights are multiples of 8 (page height).
    const COMMON_FORMATS = [
      { w: 128, h: 64, label: "128×64 (default)" },
      { w: 128, h: 32, label: "128×32" },
      { w: 96,  h: 16, label: "96×16" },
      { w: 64,  h: 48, label: "64×48" },
      { w: 64,  h: 32, label: "64×32" },
      { w: 24,  h: 24, label: "24×24" },
      { w: 16,  h: 16, label: "16×16" },
      { w: 8,   h: 8,  label: "8×8" }
    ];

    // ---- 4-level thresholds (edit if you want) ----
    // avg <= T0 => BLACK
    // T0 < avg <= T1 => DARK_GRAY
    // T1 < avg <= T2 => LIGHT_GRAY
    // avg > T2 => WHITE
    const T0 = 63;
    const T1 = 127;
    const T2 = 191;

    const LEVEL = Object.freeze({
      BLACK: 0,
      DARK: 1,
      LIGHT: 2,
      WHITE: 3
    });

    let lastBytes1 = null;
    let lastBytes2 = null;
    let lastCombined = null;

    const imgInput = document.getElementById('imgInput');
    const sizeSelect = document.getElementById('sizeSelect');

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });

    const canvasOut1 = document.getElementById('canvasOut1');
    const ctxOut1 = canvasOut1.getContext('2d', { willReadFrequently: true });

    const canvasOut2 = document.getElementById('canvasOut2');
    const ctxOut2 = canvasOut2.getContext('2d', { willReadFrequently: true });

    const output = document.getElementById('output');
    const statusEl = document.getElementById('status');
    const dimBadge = document.getElementById('dimBadge');

    const useXor = document.getElementById('xorChk').checked;
    const useXY  = document.getElementById('xyChk').checked;


    function populateFormats() {
      sizeSelect.innerHTML = '';
      COMMON_FORMATS.forEach((f, idx) => {
        const opt = document.createElement('option');
        opt.value = `${f.w}x${f.h}`;
        opt.textContent = f.label || `${f.w}×${f.h}`;
        if (idx === 4) opt.selected = true;
        sizeSelect.appendChild(opt);
      });
    }

    function parseWH(v) {
      const [w, h] = v.split('x').map(n => parseInt(n, 10));
      return { w, h };
    }

    function resizeAllCanvases(w, h) {
      // main
      canvas.width = w; canvas.height = h;
      ctx.fillStyle = '#000'; ctx.fillRect(0, 0, w, h);

      // outputs
      canvasOut1.width = w; canvasOut1.height = h;
      ctxOut1.fillStyle = '#000'; ctxOut1.fillRect(0, 0, w, h);

      canvasOut2.width = w; canvasOut2.height = h;
      ctxOut2.fillStyle = '#000'; ctxOut2.fillRect(0, 0, w, h);

      dimBadge.textContent = `${w}×${h}`;
      statusEl.textContent = `Canvases resized to ${w}×${h}`;
    }

    function drawImageNoScale(img) {
      ctx.drawImage(img, 0, 0); // clipped if larger than canvas
      statusEl.textContent = `Image drawn at native size (${img.naturalWidth}×${img.naturalHeight}), no scaling.`;
    }

    function avgToLevel(avg) {
      if (avg <= T0) return LEVEL.BLACK;
      if (avg <= T1) return LEVEL.DARK;
      if (avg <= T2) return LEVEL.LIGHT;
      return LEVEL.WHITE;
    }

    function levelToByte(level) {
      // Preview shades on the quantized canvas
      // BLACK=0, DARK≈85, LIGHT≈170, WHITE=255
      if (level === LEVEL.BLACK) return 0;
      if (level === LEVEL.DARK) return 85;
      if (level === LEVEL.LIGHT) return 170;
      return 255;
    }

    // Quantize the main canvas to 4 levels (in-place) and return a Uint8Array of per-pixel LEVEL codes.
    function quantizeTo4LevelsAndGetMap() {
      const w = canvas.width, h = canvas.height;
      const imgData = ctx.getImageData(0, 0, w, h);
      const d = imgData.data;
      const map = new Uint8Array(w * h);

      for (let p = 0, i = 0; i < d.length; i += 4, p++) {
        const r = d[i], g = d[i + 1], b = d[i + 2];
        const avg = (r + g + b) / 3;
        const level = avgToLevel(avg);
        map[p] = level;

        const v = levelToByte(level);
        d[i] = d[i + 1] = d[i + 2] = v;
        d[i + 3] = 255;
      }

      ctx.putImageData(imgData, 0, 0);
      statusEl.textContent = `Quantized to 4 levels using thresholds: ${T0}, ${T1}, ${T2}.`;
      return map;
    }

    // Split 4-level map into two B/W images (also render previews), and return two boolean maps (0/1) for white pixels.
    function splitToTwoBW(levelMap) {
      const w = canvas.width, h = canvas.height;
      const out1 = new Uint8Array(w * h); // 1=white, 0=black
      const out2 = new Uint8Array(w * h);

      const img1 = ctxOut1.createImageData(w, h);
      const img2 = ctxOut2.createImageData(w, h);

      for (let p = 0; p < levelMap.length; p++) {
        const level = levelMap[p];

        // Rules:
        // white -> white on both
        // light -> out1 black, out2 white
        // dark  -> out1 white, out2 black
        // black -> black on both
        const w1 = (level === LEVEL.WHITE || level === LEVEL.DARK) ? 1 : 0;
        const w2 = (level === LEVEL.WHITE || level === LEVEL.LIGHT) ? 1 : 0;

        out2[p] = w1;
        out1[p] = w2;

        const v1 = w1 ? 255 : 0;
        const v2 = w2 ? 255 : 0;

        const i = p * 4;
        img1.data[i] = img1.data[i + 1] = img1.data[i + 2] = v1; img1.data[i + 3] = 255;
        img2.data[i] = img2.data[i + 1] = img2.data[i + 2] = v2; img2.data[i + 3] = 255;
      }

      ctxOut1.putImageData(img1, 0, 0);
      ctxOut2.putImageData(img2, 0, 0);
      statusEl.textContent = 'Split into two B/W output images.';
      return { out1, out2 };
    }

    // Build SSD1306 bytes from a 1-bit map (Uint8Array, 1=white), page order, vertical bytes.
    function buildSSD1306BitmapFromBWMap(bwMap) {
      const w = canvas.width, h = canvas.height;
      const bytes = [];

      for (let pageY = 0; pageY < h; pageY += 8) {
        for (let x = 0; x < w; x++) {
          let byte = 0;
          for (let bit = 0; bit < 8; bit++) {
            const y = pageY + bit;
            if (y >= h) break;
            const p = y * w + x;
            if (bwMap[p]) byte |= (1 << bit); // LSB at top
          }
          bytes.push(byte);
        }
      }
      return bytes;
    }

    function toHexLines(bytes, perLine = 16) {
      const hex = bytes.map(b => '0x' + b.toString(16).padStart(2, '0'));
      const lines = [];
      for (let i = 0; i < hex.length; i += perLine) {
        lines.push('  ' + hex.slice(i, i + perLine).join(', '));
      }
      return lines.join(',\n');
    }

function concatArrays(a, b) {
  const out = new Uint8Array(a.length + b.length);
  out.set(a, 0);
  out.set(b, a.length);
  return out;
}

function xorSecondHalfInPlace(combined) {
  // combined layout: [A...][B...], with equal halves
  const half = combined.length >>> 1;
  for (let i = 0; i < half; i++) {
    combined[half + i] ^= combined[i]; // B ^= A
  }
  return combined;
}

function xyTransformHalf_PageMajorToColMajor(src, w, pages) {
  // src length = w*pages, layout: src[page*w + x]
  // dst layout: dst[x*pages + page]
  const dst = new Uint8Array(src.length);
  for (let x = 0; x < w; x++) {
    const base = x * pages;
    for (let p = 0; p < pages; p++) {
      dst[base + p] = src[p * w + x];
    }
  }
  return dst;
}

function xyTransformHalf_ColMajorToPageMajor(src, w, pages) {
  // inverse of above
  const dst = new Uint8Array(src.length);
  for (let p = 0; p < pages; p++) {
    const row = p * w;
    for (let x = 0; x < w; x++) {
      dst[row + x] = src[x * pages + p];
    }
  }
  return dst;
}

// Apply X->Y to BOTH halves of combined [A][B]
function xyTransformBothHalves(combined, w, pages) {
  const half = combined.length >>> 1;
  const A = combined.slice(0, half);
  const B = combined.slice(half);

  const A2 = xyTransformHalf_PageMajorToColMajor(A, w, pages);
  const B2 = xyTransformHalf_PageMajorToColMajor(B, w, pages);

  const out = new Uint8Array(combined.length);
  out.set(A2, 0);
  out.set(B2, half);
  return out;
}



// ---------- ZeroRun encoder ----------
// Format:
// token t < 128  => literal run length = t+1, followed by that many bytes
// token t >= 128 => zero run length = t-127, outputs that many 0x00 bytes
function zerorunCompress(raw) {
  const out = [];
  let i = 0;

  while (i < raw.length) {
    // Zero run?
    if (raw[i] === 0) {
      let z = 1;
      while (i + z < raw.length && raw[i + z] === 0 && z < 128) z++;

      // Encode as zero-run token: 128..255 means 1..128 zeros
      out.push(127 + z);
      i += z;
      continue;
    }

    // Literal run: until next zero-run start OR 128 bytes
    const litStart = i;
    let n = 0;
    while (i < raw.length && raw[i] !== 0 && n < 128) { i++; n++; }

    out.push(n - 1); // token 0..127 means 1..128 literal bytes
    for (let k = 0; k < n; k++) out.push(raw[litStart + k]);
  }

  return new Uint8Array(out);
}

// ---------- PackBits encoder ----------
// Standard PackBits:
// n = 0..127: copy next n+1 bytes literal
// n = -1..-127: repeat next byte (1 - n) times  (i.e., 2..128 times)
// n = -128: noop (not used here)
function packbitsCompress(raw) {
  const out = [];
  let i = 0;

  function emitLiteral(buf) {
    // buf length 1..128
    out.push(buf.length - 1);
    for (let b of buf) out.push(b);
  }
  function emitRepeat(byteVal, count) {
    // count 2..128
    out.push((256 - (count - 1)) & 0xFF); // -(count-1) as uint8
    out.push(byteVal);
  }

  while (i < raw.length) {
    // Detect repeat run
    let runByte = raw[i];
    let runLen = 1;
    while (i + runLen < raw.length && raw[i + runLen] === runByte && runLen < 128) runLen++;

    // Only worth encoding repeat if len >= 3 (classic PackBits heuristic)
    if (runLen >= 3) {
      emitRepeat(runByte, runLen);
      i += runLen;
      continue;
    }

    // Otherwise build a literal block up to 128, but stop before a repeat >=3 starts
    const lit = [];
    while (i < raw.length && lit.length < 128) {
      // Check if a repeat run >=3 starts at i
      runByte = raw[i];
      runLen = 1;
      while (i + runLen < raw.length && raw[i + runLen] === runByte && runLen < 128) runLen++;
      if (runLen >= 3) break;

      lit.push(raw[i]);
      i++;
    }
    emitLiteral(lit);
  }

  return new Uint8Array(out);
}

function toHexLinesFromUint8(bytes, perLine = 16) {
  const arr = Array.from(bytes);
  return toHexLines(arr, perLine);
}

function arduinoDecompressSnippet(codecName, packedName, packedLen, rawLen, useXor, useXY, w, h) 
{


  const pages = (h / 8) | 0;

  const postRestore = `
  // Post-decompression transforms from header flags:
  // bit0: bitmap2 stored as (bitmap2 ^ bitmap1)
  // bit1: both halves stored in X->Y (col-major) layout

  const uint16_t half = raw_len / 2;

  if (flags & 0x01) {
    // Restore bitmap2: (bitmap2^bitmap1) ^ bitmap1
    for (uint16_t i = 0; i < half; i++) {
      decoded[half + i] ^= decoded[i];
    }
  }
`;
/*
  if (flags & 0x02) {
    // Inverse X->Y on both halves: col-major -> SSD1306 page-major
    const uint8_t W = ${w};
    const uint8_t PAGES = ${pages};
    const uint16_t BYTES = (uint16_t)W * PAGES;

    // Scratch for one half (fits 64x32=256, 128x64=1024)
    static uint8_t tmp[${w * pages}];

    auto invXY = [&](uint8_t* buf) {
      for (uint8_t p = 0; p < PAGES; p++) {
        uint16_t row = (uint16_t)p * W;
        for (uint8_t x = 0; x < W; x++) {
          tmp[row + x] = buf[(uint16_t)x * PAGES + p];
        }
      }
      for (uint16_t i = 0; i < BYTES; i++) buf[i] = tmp[i];
    };

    invXY(decoded);
    invXY(decoded + half);
  }
`;
*/


  // Provide one snippet that compiles on AVR (PROGMEM read)
  if (codecName === "ZeroRun") {
    return `
// ---- Arduino ZeroRun decompressor (PROGMEM source) ----
#include <Arduino.h>
#include <avr/pgmspace.h>

static bool decode_zerorun_P(const uint8_t* srcP, uint16_t srcLen, uint8_t* dst, uint16_t dstLen) {
  uint16_t si = 0, di = 0;
  while (si < srcLen && di < dstLen) {
    uint8_t t = pgm_read_byte(srcP + si++);
    if (t < 128) {
      uint16_t n = (uint16_t)t + 1u;
      if (si + n > srcLen) return false;
      if (di + n > dstLen) return false;
      while (n--) dst[di++] = pgm_read_byte(srcP + si++);
    } else {
      uint16_t n = (uint16_t)t - 127u; // 1..128
      if (di + n > dstLen) return false;
      while (n--) dst[di++] = 0x00;
    }
  }
  return (di == dstLen);
}

// Example: decompress into a RAM buffer (bitmap1 followed by bitmap2)
static uint8_t decoded[${rawLen}];

void decompressExample() {
  const uint8_t flags = pgm_read_byte(${packedName});
  const uint8_t* src = ${packedName} + 1;
  const uint16_t srcLen = sizeof(${packedName}) - 1;
  const bool ok = decode_zerorun_P(src, srcLen, decoded, ${rawLen});

if (!ok) {
    // handle error
  }

  ${postRestore}

  // decoded[] now equals: original bitmap1 bytes then bitmap2 bytes
}

`;
  }

  // PackBits
  return `
// ---- Arduino PackBits decompressor (PROGMEM source) ----
#include <Arduino.h>
#include <avr/pgmspace.h>

static bool decode_packbits_P(const uint8_t* srcP, uint16_t srcLen, uint8_t* dst, uint16_t dstLen) {
  uint16_t si = 0, di = 0;
  while (si < srcLen && di < dstLen) {
    int8_t n = (int8_t)pgm_read_byte(srcP + si++);
    if (n >= 0) {
      uint16_t count = (uint16_t)n + 1u;
      if (si + count > srcLen) return false;
      if (di + count > dstLen) return false;
      while (count--) dst[di++] = pgm_read_byte(srcP + si++);
    } else if (n != -128) {
      uint16_t count = (uint16_t)(1 - n); // 2..128
      if (si >= srcLen) return false;
      uint8_t v = pgm_read_byte(srcP + si++);
      if (di + count > dstLen) return false;
      while (count--) dst[di++] = v;
    } // -128 => noop
  }
  return (di == dstLen);
}

// Example: decompress into a RAM buffer (bitmap1 followed by bitmap2)
static uint8_t decoded[${rawLen}];

void decompressExample() {
  const uint8_t flags = pgm_read_byte(${packedName});
  const uint8_t* src = ${packedName} + 1;
  const uint16_t srcLen = sizeof(${packedName}) - 1;
  const bool ok = decode_packbits_P(src, srcLen, decoded, ${rawLen});
  
  
  if (!ok) {
    // handle error
  }

  ${postRestore}

  // decoded[] now equals: original bitmap1 bytes then bitmap2 bytes
}

`;
}

function generatePackedOutput(codecLabel, packedArrayName, packedBytes, rawBytes, w, h, useXor, useXY)
{
  const rawLen = rawBytes.length;
  const flags = (useXor ? 1 : 0) | (useXY ? 2 : 0);

  // Prefix packed stream with 1-byte header (flags)
  const packedWithHdr = new Uint8Array(packedBytes.length + 1);
  packedWithHdr[0] = flags;
  packedWithHdr.set(packedBytes, 1);

  const packedLen2 = packedWithHdr.length;
  const ratio = (packedLen2 / rawLen * 100).toFixed(1);


return `// ${codecLabel} compressed package for SSD1306 bitmap1+bitmap2 (concatenated)
// Flags byte at start: bit0=useXor, bit1=X->Y
// Flags used: 0x${flags.toString(16).padStart(2,'0')}
// XOR pre-process on bitmap2: ${useXor ? 'YES (stored as bitmap2^bitmap1)' : 'NO'}
// X->Y transform: ${useXY ? 'YES (page-major -> col-major before compression)' : 'NO'}
// Raw length = ${rawLen} bytes
// Packed length (incl 1-byte header) = ${packedLen2} bytes (${ratio}% of raw)

#include <Arduino.h>
#include <avr/pgmspace.h>

const uint8_t ${packedArrayName}[] PROGMEM = {
${toHexLinesFromUint8(packedWithHdr)}
};

${arduinoDecompressSnippet(codecLabel, packedArrayName, packedLen2, rawLen, useXor, useXY, w, h)}
`;
}

    function generateOutputTwo(bytes1, bytes2) {
      const w = canvas.width, h = canvas.height;
      const count = bytes1.length;

      const name1 = `bitmap1_${w}x${h}`;
      const name2 = `bitmap2_${w}x${h}`;

      return `// SSD1306 bitmaps for ${w}x${h} (pages of 8px, vertical bytes, LSB at y=0)
 // Total bytes per bitmap: ${count}

#include <Tiny4kOLED.h>

const uint8_t ${name1}[] PROGMEM = {
${toHexLines(bytes1)}
};

const uint8_t ${name2}[] PROGMEM = {
${toHexLines(bytes2)}
};

// Example usage with Tiny4kOLED:
// oled.switchRenderFrame();
// oled.bitmap(0, 0, ${w}, ${h >> 3}, ${name1});
// oled.switchFrame();
// oled.bitmap(0, 0, ${w}, ${h >> 3}, ${name2});
`;
    }

    // Keep latest computed maps so buttons work in any order.
    let lastLevelMap = null;
    let lastBW = null;

    // Events
    sizeSelect.addEventListener('change', () => {
      const { w, h } = parseWH(sizeSelect.value);
      resizeAllCanvases(w, h);
      output.value = '';
      lastLevelMap = null;
      lastBW = null;
    });

    imgInput.addEventListener('change', (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;

      const img = new Image();
      img.onload = () => {
        // Clear to black, then draw image without scaling
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctxOut1.fillStyle = '#000'; ctxOut1.fillRect(0, 0, canvasOut1.width, canvasOut1.height);
        ctxOut2.fillStyle = '#000'; ctxOut2.fillRect(0, 0, canvasOut2.width, canvasOut2.height);

        drawImageNoScale(img);

        // Auto-run quantize + split (like your original auto-binarize)
        lastLevelMap = quantizeTo4LevelsAndGetMap();
        lastBW = splitToTwoBW(lastLevelMap);
      };
      img.onerror = () => { statusEl.textContent = 'Failed to load image.'; };

      const reader = new FileReader();
      reader.onload = (ev) => { img.src = ev.target.result; };
      reader.readAsDataURL(file);
    });

    document.getElementById('quantizeBtn').addEventListener('click', () => {
      lastLevelMap = quantizeTo4LevelsAndGetMap();
      lastBW = null; // needs re-split
      output.value = '';
    });

    document.getElementById('splitBtn').addEventListener('click', () => {
      if (!lastLevelMap) lastLevelMap = quantizeTo4LevelsAndGetMap();
      lastBW = splitToTwoBW(lastLevelMap);
      output.value = '';
    });

    document.getElementById('convertBtn').addEventListener('click', () => {
      if (!lastLevelMap) lastLevelMap = quantizeTo4LevelsAndGetMap();
      if (!lastBW) lastBW = splitToTwoBW(lastLevelMap);

      const bytes1 = buildSSD1306BitmapFromBWMap(lastBW.out1);
      const bytes2 = buildSSD1306BitmapFromBWMap(lastBW.out2);

      lastBytes1 = new Uint8Array(bytes1);
      lastBytes2 = new Uint8Array(bytes2);
      lastCombined = concatArrays(lastBytes1, lastBytes2);

      output.value = generateOutputTwo(bytes1, bytes2);
      statusEl.textContent = `Converted to 2×${bytes1.length} bytes (combined ${lastCombined.length}).`;

      document.getElementById('zrBtn').disabled = false;
      document.getElementById('pbBtn').disabled = false;

    });

    document.getElementById('zrBtn').addEventListener('click', () => {
      if (!lastCombined) { statusEl.textContent = 'Please Convert first.'; return; }
      const { w, h } = parseWH(sizeSelect.value);

      const useXor = document.getElementById('xorChk').checked;
      const useXY  = document.getElementById('xyChk').checked;

      let raw = new Uint8Array(lastCombined);

      if (useXY) {
        const pages = (h / 8) | 0;
        raw = xyTransformBothHalves(raw, w, pages);
      }
      if (useXor) {
        xorSecondHalfInPlace(raw);
      }

      const packed = zerorunCompress(raw);
      output.value = generatePackedOutput('ZeroRun', `zerorun_bitmap_${w}x${h}`, packed, raw, w, h, useXor, useXY);


      statusEl.textContent = `ZeroRun packed: ${packed.length} bytes (raw ${raw.length}).`;
    });


    document.getElementById('pbBtn').addEventListener('click', () => {
      if (!lastCombined) { statusEl.textContent = 'Please Convert first.'; return; }
      const { w, h } = parseWH(sizeSelect.value);

    const useXor = document.getElementById('xorChk').checked;
    const useXY  = document.getElementById('xyChk').checked;

    let raw = new Uint8Array(lastCombined);

    if (useXY) {
      const pages = (h / 8) | 0;
      raw = xyTransformBothHalves(raw, w, pages);
    }
    if (useXor) {
      xorSecondHalfInPlace(raw);
    }

    const packed = packbitsCompress(raw);
    output.value = generatePackedOutput('PackBits', `packbits_bitmap_${w}x${h}`, packed, raw, w, h, useXor, useXY);



      statusEl.textContent = `PackBits packed: ${packed.length} bytes (raw ${raw.length}).`;
    });




    document.getElementById('copyBtn').addEventListener('click', async () => {
      try {
        await navigator.clipboard.writeText(output.value);
        statusEl.textContent = 'Copied output to clipboard.';
      } catch (e) {
        statusEl.textContent = 'Copy failed. You can copy manually from the textbox.';
      }
    });



    // Init
    populateFormats();
    const { w, h } = parseWH(sizeSelect.value || '128x64');
    resizeAllCanvases(w, h);
  </script>
</body>
</html>
